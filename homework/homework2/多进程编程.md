# 多进程编程
####  组名：The three stooges
#### 小组成员：曾毓宁、徐锦畅、唐培津
## 一、实验目的

1、学会创建多进程程序，理解fork()，vfork()创建的子进程的特点。    

2、学会使用有名管道和无名管道实现进程间通信。   

3、学会使用信号机制实现进程间通信。   

## 二、实验内容

1、编写fork()，vfork()多进程程序，通过输出结果比较所创建的子进程的不同之处。     

2、编写fork()多进程程序，进程间模拟信号通信，包括信号发送、捕捉与处理。   

3、编写fork()多进程程序，进程间实现有名管道和无名管道通信。具体要求如下：   

* 编写1个服务器程序server.c和2个客户端程序client1.c, client2.c ，服务器和客户端之间采用FIFO管道通信；   

* 服务器和客户端各自创建自己的子进程，父进程负责完成FIFO管道通信，子进程负责输出接收到的信息，父子进程间采用无名管道通信。   

## 三、实验过程与结果

**1、** 编写一个fork（）多进程程序。该程序在父进程中没有调用wait（）或waitpid（），结果如下所示。可以看到子进程的ppid为1。出现这个现象的原因是父进程先于子进程结束，子进程变成孤儿进程，被init收养。

![1](https://github.com/xjc97/The_Three_Stooges/blob/master/homework/homework2/images/1.png)
加入wait()后，子进程ppid为其父进程pid。这里还加入了WIFEXITED（status）和WEXITSTATUS(status)宏来检查子进程的状态。

![2](https://github.com/xjc97/The_Three_Stooges/blob/master/homework/homework2/images/2.png)
最后，我尝试加入exec()。Exec()和system()的作用类似，都是进入一个新进程，它们的区别是system()会返回调用进程，而exec()直接覆盖了原有进程。加入后结果如下所示，可以看到此时子进程的返回数已不是233，而是默认的0。说明exec()后的exit(233)没有执行。

![3](https://github.com/xjc97/The_Three_Stooges/blob/master/homework/homework2/images/3.png)

****

**2、** 编写一个vfork程序。结果如下。Vfork中父子进程共享内存，且子进程优先运行，所以父进程运行后bound结果为1100。

![4](https://github.com/xjc97/The_Three_Stooges/blob/master/homework/homework2/images/4.png)
  至此，我们可以比较fork和vfork的异同。    
  相同之处是，fork和vfork在调用执行中会返回3个值（已算上错误信息），且在不调用exec()的情况下，父子进程均共享代码段。    
  不同之处是，fork创建子进程时会复制父进程全部资源，但不与父进程共享内存，并且父进程可以在子进程结束前结束；vfork创建子进程时只是复制了父进程的指针，父子进程共享内存，和线程区别不大，并且父进程会在子进程运行结束后运行。   
  为了数据安全，我们在工作中应谨慎使用vfork。  

****

**3、** 编写fork()多进程程序，模拟信号通信。这里我先编写了一个使用kill()发送信号的程序，结果如下。在子进程运行之前父进程已经执行删除子进程的操作，因此不会执行子进程（这里父子进程执行顺序不固定，由系统资源统一分配）。在父进程中加入sleep(1)后，确认kill正常发送函数。

![5](https://github.com/xjc97/The_Three_Stooges/blob/master/homework/homework2/images/5.png)
随后，编写含有信号发送、捕获与处理的fork程序。结果如下。SIGALRM信号发送、捕获、处理正常。

![6](https://github.com/xjc97/The_Three_Stooges/blob/master/homework/homework2/images/6.png)

****

**4、** 首先，编写createfifo程序，创建了四个fifo管道myfifo1、myfifo2、myfifo3、myfifo4。编译运行后生成四个fifo管道。其中myfifo1、myfifo2为server向两个client发送信号的管道，myfifo3、myfifo4为两个client向server发送确认收到信号的管道。

![7](https://github.com/xjc97/The_Three_Stooges/blob/master/homework/homework2/images/7.png)
  接着，编写服务器程序以及两个客户端程序。两个客户端client1和client2中调用fork（）创造子进程。在父进程中完成fifo管道通信，父子进程用一个无名管道通信，父进程把从fifo收到的信号通过无名管道送给子进程，在子进程中输出收到的信号。  
  在服务器程序server中，同样创建子进程。在这两个进程之间，我创建了两个无名管道，分别把server从client1和client2中收到的确认信号通过两无名管道送给子程序，在子程序中输出收到的信号。结果如下:  

![8](https://github.com/xjc97/The_Three_Stooges/blob/master/homework/homework2/images/8.png)

## 四、实验总结 
  本次实验中，我们熟悉了多进程编程，为以后进行复杂的编程工程奠定了良好的基础。

## 五、附实验源码 