# 多进程编程
####  组名：The three stooges
#### 小组成员：曾毓宁、徐锦畅、唐培津
## 一、实验目的

1、学会创建多进程程序，理解fork()，vfork()创建的子进程的特点。    

2、学会使用有名管道和无名管道实现进程间通信。   

3、学会使用信号机制实现进程间通信。   

## 二、实验内容

1、编写fork()，vfork()多进程程序，通过输出结果比较所创建的子进程的不同之处。     

2、编写fork()多进程程序，进程间模拟信号通信，包括信号发送、捕捉与处理。   

3、编写fork()多进程程序，进程间实现有名管道和无名管道通信。具体要求如下：   

* 编写1个服务器程序server.c和2个客户端程序client1.c, client2.c ，服务器和客户端之间采用FIFO管道通信；   

* 服务器和客户端各自创建自己的子进程，父进程负责完成FIFO管道通信，子进程负责输出接收到的信息，父子进程间采用无名管道通信。   

## 三、实验过程与结果

1、编写一个fork（）多进程程序。该程序在父进程中没有调用wait（）或waitpid（），结果如下所示。可以看到子进程的ppid为1。出现这个现象的原因是父进程先于子进程结束，子进程变成孤儿进程，被init收养。
![1](https://github.com/xjc97/The_Three_Stooges/blob/master/homework/homework2/images/1.png)

加入wait()后，子进程ppid为其父进程pid。这里还加入了WIFEXITED（status）和WEXITSTATUS(status)宏来检查子进程的状态。

![2](https://github.com/xjc97/The_Three_Stooges/blob/master/homework/homework2/images/2.png)
最后，我尝试加入exec()。Exec()和system()的作用类似，都是进入一个新进程，它们的区别是system()会返回调用进程，而exec()直接覆盖了原有进程。加入后结果如下所示，可以看到此时子进程的返回数已不是233，而是默认的0。说明exec()后的exit(233)没有执行。
